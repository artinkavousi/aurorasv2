{"version":3,"file":"slimdown.modern.mjs","sources":["../src/index.ts"],"sourcesContent":["export type RegexReplacer = (substring: string, ...args: any[]) => string;\n\n/**\n * Slimdown - A very basic regex-based Markdown parser. Supports the\n * following elements (and can be extended via Slimdown::add_rule()):\n *\n * - Headers\n * - Images\n * - Links\n * - Bold\n * - Emphasis\n * - Deletions\n * - Quotes\n * - Inline code\n * - Code blocks\n * - Blockquotes\n * - Ordered/unordered lists (one level only)\n * - Horizontal rules\n * - Superscript and subscript (`z_1_` or `a^2^`)\n *\n * Original author: Johnny Broadway <johnny@johnnybroadway.com>\n * Website: https://gist.github.com/jbroadway/2836900\n * Inspiration:\n * - https://gist.github.com/plugnburn/f0d12e38b6416a77c098\n * - https://github.com/Chalarangelo/parse-md-js/blob/master/parsemd.js\n * - https://gist.github.com/plugnburn/f0d12e38b6416a77c098\n *\n * Author: Erik Vullings <erik.vullings@gmail.com>\n * Conversion from PHP to TypeScript, applying fixes and tests, adding more elements, and publishing to npm:\n * Website: https://github.com/erikvullings/slimdown-js\n * License: MIT\n */\n\n// Store code blocks temporarily to prevent markdown processing within them\nconst codeBlocks: string[] = [];\nconst inlineCode: string[] = [];\n// Store math expressions to prevent markdown processing within them\nconst mathBlocks: string[] = [];\nconst inlineMath: string[] = [];\n// Store footnotes\nconst footnotes: Array<[id: string, text: string]> = [];\n\nconst escapeMap: Record<string, string> = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\n\nconst escRegex = new RegExp(`[${Object.keys(escapeMap).join('')}]`, 'g');\n\nconst esc = (s: string): string =>\n  s.replace(escRegex, (match) => escapeMap[match]);\n\nconst para = (_: string, line: string) => {\n  const trimmed = line.trim();\n  return /^<\\/?(ul|ol|li|h|p|bl|table|tbody|tr|td|th|caption)/i.test(trimmed) || trimmed === ''\n    ? `\\n${line}\\n`\n    : `\\n<p>\\n${trimmed}\\n</p>\\n`;\n};\n\nconst ulList = (\n  _text: string,\n  indent: string,\n  _bullet: string,\n  item: string,\n) => {\n  const level = Math.floor(indent.length / 2);\n  return `\\n{{LISTITEM:ul:${level}:${item.trim()}}}\\n`;\n};\n\nconst olList = (\n  _text: string,\n  indent: string,\n  _bullet: string,\n  item: string,\n) => {\n  const level = Math.floor(indent.length / 2);\n  return `\\n{{LISTITEM:ol:${level}:${item.trim()}}}\\n`;\n};\n\nconst blockquote = (_: string, __: string, item = '') =>\n  `\\n<blockquote>${item.trim()}</blockquote>`;\n\nconst taskList = (\n  _text: string,\n  indent: string,\n  checkboxState: string,\n  item: string,\n) => {\n  const level = Math.floor(indent.length / 2);\n  const checked = checkboxState.toLowerCase() === 'x';\n  const checkboxHtml = `<input type=\"checkbox\"${\n    checked ? ' checked' : ''\n  } disabled>`;\n  return `\\n{{LISTITEM:ul:${level}:${checkboxHtml} ${item.trim()}}}\\n`;\n};\n\nconst definitionList = (_: string, term: string, definition: string) => {\n  return `\\n<dl><dt>${term.trim()}</dt><dd>${definition.trim()}</dd></dl>\\n`;\n};\n\n// Function to process list items into proper nested HTML\nconst processListItems = (markdown: string): string => {\n  if (!markdown.includes('{{LISTITEM:')) return markdown;\n\n  // Find groups of consecutive list items separated by non-list content\n  const lines = markdown.split('\\n');\n  const groups: Array<\n    Array<{\n      type: 'ul' | 'ol';\n      level: number;\n      content: string;\n      originalLine: string;\n    }>\n  > = [];\n  let currentGroup: Array<{\n    type: 'ul' | 'ol';\n    level: number;\n    content: string;\n    originalLine: string;\n  }> = [];\n\n  let hasEmptyLineSinceLastItem = false;\n\n  for (const line of lines) {\n    const listMatch = line.match(/\\{\\{LISTITEM:([^:]+):([^:]+):(.+)\\}\\}/);\n    if (listMatch) {\n      const itemType = listMatch[1] as 'ul' | 'ol';\n      const itemLevel = parseInt(listMatch[2]);\n\n      // Check if we should break the group due to type change after empty line\n      if (hasEmptyLineSinceLastItem && currentGroup.length > 0) {\n        const lastItem = currentGroup[currentGroup.length - 1];\n        // Break group if type changes at the same level after empty line\n        if (lastItem.type !== itemType && lastItem.level === itemLevel) {\n          groups.push([...currentGroup]);\n          currentGroup = [];\n        }\n      }\n\n      currentGroup.push({\n        type: itemType,\n        level: itemLevel,\n        content: listMatch[3],\n        originalLine: line,\n      });\n      hasEmptyLineSinceLastItem = false;\n    } else if (line.trim() !== '') {\n      // Non-empty, non-list line - end current group\n      if (currentGroup.length > 0) {\n        groups.push([...currentGroup]);\n        currentGroup = [];\n      }\n      hasEmptyLineSinceLastItem = false;\n    } else if (line.trim() === '') {\n      // Empty line\n      hasEmptyLineSinceLastItem = true;\n    }\n  }\n\n  // Add final group if any\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  }\n\n  if (groups.length === 0) return markdown;\n\n  // Process each group separately\n  for (const group of groups) {\n    const html = buildNestedList(group);\n\n    // Replace first item in group with the complete HTML\n    const firstItem = group[0];\n    markdown = markdown.replace(firstItem.originalLine, html);\n\n    // Remove remaining items in group\n    for (let i = 1; i < group.length; i++) {\n      markdown = markdown.replace(group[i].originalLine, '');\n    }\n  }\n\n  return markdown;\n};\n\n// Build nested HTML from a group of list items\nconst buildNestedList = (\n  listItems: Array<{\n    type: 'ul' | 'ol';\n    level: number;\n    content: string;\n    originalLine: string;\n  }>,\n): string => {\n  if (listItems.length === 0) return '';\n\n  let html = '';\n  const stack: Array<{ type: 'ul' | 'ol'; level: number; hasOpenLi: boolean }> =\n    [];\n\n  for (let i = 0; i < listItems.length; i++) {\n    const item = listItems[i];\n    const nextItem = i < listItems.length - 1 ? listItems[i + 1] : null;\n\n    // Close lists that are deeper than current level\n    while (stack.length > 0 && stack[stack.length - 1].level > item.level) {\n      const last = stack.pop()!;\n      if (last.hasOpenLi) {\n        html += '</li>';\n      }\n      html += `</${last.type}>`;\n    }\n\n    // Close current list if switching types at same level\n    if (\n      stack.length > 0 &&\n      stack[stack.length - 1].level === item.level &&\n      stack[stack.length - 1].type !== item.type\n    ) {\n      const last = stack.pop()!;\n      if (last.hasOpenLi) {\n        html += '</li>';\n      }\n      html += `</${last.type}>`;\n    }\n\n    // Open new list if needed\n    if (stack.length === 0 || stack[stack.length - 1].level < item.level) {\n      html += `<${item.type}>`;\n      stack.push({ type: item.type, level: item.level, hasOpenLi: false });\n    }\n\n    // Close previous li at same level if needed\n    if (\n      stack.length > 0 &&\n      stack[stack.length - 1].hasOpenLi &&\n      stack[stack.length - 1].level === item.level\n    ) {\n      html += '</li>';\n      stack[stack.length - 1].hasOpenLi = false;\n    }\n\n    // Add list item\n    html += `<li>${item.content}`;\n    stack[stack.length - 1].hasOpenLi = true;\n\n    // Close li if next item is not deeper\n    if (!nextItem || nextItem.level <= item.level) {\n      html += '</li>';\n      stack[stack.length - 1].hasOpenLi = false;\n    }\n  }\n\n  // Close remaining lists\n  while (stack.length > 0) {\n    const last = stack.pop()!;\n    if (last.hasOpenLi) {\n      html += '</li>';\n    }\n    html += `</${last.type}>`;\n  }\n\n  return html;\n};\n\n// Process footnote references in the text [^1]\nconst footnoteReferenceReplacer = (_match: string, id: string) => {\n  // Create a link inside a superscript tag with proper references\n  return `<sup id=\"fnref:${id}\"><a href=\"#fn:${id}\">[${id}]</a></sup>`;\n};\n\n// Process footnote definitions [^1]: Footnote text\nconst footnoteDefinitionReplacer = (\n  _match: string,\n  id: string,\n  text: string,\n) => {\n  footnotes.push([id, text.trim()]);\n  return ''; // Remove the definition from the main text\n};\n\n// Generate the footnotes section\nconst generateFootnotesSection = () => {\n  if (footnotes.length === 0) return '';\n\n  const footnotesHtml = footnotes\n    .map(\n      ([id, text]) => `\n    <li id=\"fn:${id}\">\n      ${text}\n      <sup><a href=\"#fnref:${id}\">â†©</a></sup>\n    </li>`,\n    )\n    .join('\\n');\n\n  return `\n<div class=\"footnotes\">\n  <hr>\n  <ol>\n    ${footnotesHtml}\n  </ol>\n</div>`;\n};\n\nconst table = (\n  _: string,\n  headers: string,\n  format: string,\n  content: string = '',\n) => {\n  const align = format\n    .split('|')\n    .filter((__, i, arr) => i > 0 && i < arr.length - 1)\n    .map((col) =>\n      /:-+:/g.test(col)\n        ? 'center'\n        : /-+:/g.test(col)\n        ? 'right'\n        : /:-+/.test(col)\n        ? 'left'\n        : '',\n    );\n\n  // Return attribute string (keeps compatibility with original code's template)\n  const td = (col: number) => {\n    const a = align[col];\n    return a ? ` align=\"${a}\"` : '';\n  };\n\n  // Parse header cells (keep both raw and trimmed for emptiness checks)\n  const rawHeaderCells = headers.split('|').slice(1, -1); // remove first and last empty elements\n  const headerCells = rawHeaderCells.map((hd) => hd.trim());\n\n  const headerResults: string[] = [];\n  let skipNext = 0;\n\n  for (let i = 0; i < headerCells.length; i++) {\n    if (skipNext > 0) {\n      skipNext--;\n      continue;\n    }\n\n    const hd = headerCells[i];\n    const rawHd = rawHeaderCells[i];\n    \n    if (hd && hd.length) {\n      // count how many consecutive empty header cells follow -> colspan\n      // Only do colspan if there's at least one truly empty cell (from ||) in the sequence\n      let spanCount = 1;\n      let hasTrulyEmptyCell = false;\n      \n      // Check if there are any truly empty cells following this cell\n      for (let j = i + 1; j < headerCells.length && headerCells[j].length === 0; j++) {\n        if (rawHeaderCells[j] === '') {\n          hasTrulyEmptyCell = true;\n          break;\n        }\n      }\n      \n      // Only count consecutive empty cells for colspan if we found truly empty cells\n      if (hasTrulyEmptyCell) {\n        for (\n          let j = i + 1;\n          j < headerCells.length && headerCells[j].length === 0;\n          j++\n        ) {\n          spanCount++;\n        }\n      }\n\n      if (spanCount > 1) {\n        skipNext = spanCount - 1;\n        headerResults.push(`<th${td(i)} colspan=\"${spanCount}\">${hd}</th>`);\n      } else {\n        headerResults.push(`<th${td(i)}>${hd}</th>`);\n      }\n    } else {\n      // Check if this is a truly empty cell (from ||) or just whitespace\n      if (rawHd === '') {\n        // This is a truly empty cell that should be skipped for colspan\n        // But if we reach here, it means it wasn't part of a colspan, so render empty th\n        headerResults.push(`<th${td(i)}></th>`);\n      } else {\n        // This is a whitespace-only cell that should remain as individual cell\n        headerResults.push(`<th${td(i)}></th>`);\n      }\n    }\n  }\n\n  const h = `<tr>\\n  ${headerResults.join('\\n  ')}\\n</tr>\\n`;\n\n  // body rows\n  const rows = content\n    .split('\\n')\n    .map((row) => row.trim())\n    .filter((row) => row && row.length);\n\n  const c = rows\n    .map((row) => {\n      // Split by | but keep track of truly empty cells (from ||)\n      const rawCells = row.split('|').slice(1, -1); // remove first and last empty elements\n      const cells = rawCells.map((cell) => cell.trim());\n\n      const cellResults: string[] = [];\n      let skipNext = 0;\n\n      for (let i = 0; i < cells.length; i++) {\n        if (skipNext > 0) {\n          skipNext--;\n          continue;\n        }\n\n        const cell = cells[i];\n        const rawCell = rawCells[i];\n        \n        if (cell && cell.length) {\n          // Count consecutive empty cells after this one -> colspan\n          // Only do colspan if there's at least one truly empty cell (from ||) in the sequence\n          let spanCount = 1;\n          let hasTrulyEmptyCell = false;\n          \n          // Check if there are any truly empty cells following this cell\n          for (let j = i + 1; j < cells.length && cells[j].length === 0; j++) {\n            if (rawCells[j] === '') {\n              hasTrulyEmptyCell = true;\n              break;\n            }\n          }\n          \n          // Only count consecutive empty cells for colspan if we found truly empty cells\n          if (hasTrulyEmptyCell) {\n            for (\n              let j = i + 1;\n              j < cells.length && cells[j].length === 0;\n              j++\n            ) {\n              spanCount++;\n            }\n          }\n          if (spanCount > 1) {\n            skipNext = spanCount - 1;\n            cellResults.push(`<td${td(i)} colspan=\"${spanCount}\">${cell}</td>`);\n          } else {\n            cellResults.push(`<td${td(i)}>${cell}</td>`);\n          }\n        } else {\n          // Check if this is a truly empty cell (from ||) or just whitespace\n          if (rawCell === '') {\n            // This is a truly empty cell that should be skipped for colspan\n            // But if we reach here, it means it wasn't part of a colspan, so render empty td\n            cellResults.push(`<td${td(i)}></td>`);\n          } else {\n            // This is a whitespace-only cell that should remain as individual cell\n            cellResults.push(`<td${td(i)}></td>`);\n          }\n        }\n      }\n\n      return `<tr>\\n  ${cellResults.join('\\n  ')}\\n</tr>\\n`;\n    })\n    .join('');\n\n  // keep the original surrounding newlines/structure to stay compatible\n  return `\\n<table><tbody>${h}${c}</tbody></table>\\n`;\n};\n\n// Enhanced table with caption support\nconst tableWithCaption = (\n  _: string,\n  caption: string,\n  headers: string,\n  format: string,\n  content: string = '',\n) => {\n  const tableHtml = table(_, headers, format, content);\n  // Insert caption after <table> tag\n  return tableHtml.replace(\n    '<table>',\n    `<table><caption>${caption.trim()}</caption>`,\n  );\n};\n\nconst cleanUpUrl = (link: string) => link.replace(/<\\/?em>/g, '_');\n\nconst header = (_: string, match: string, h = '') => {\n  const level = match.length;\n  return `<h${level}>${h.trim()}</h${level}>`;\n};\n\n// Function to extract and store code blocks\nconst extractCodeBlocks = (markdown: string): string => {\n  return markdown.replace(\n    /\\n\\s*```\\w*\\n([^]*?)\\n\\s*```\\s*\\n/g,\n    (_match, code) => {\n      codeBlocks.push(code);\n      return `\\n<pre>{{CODEBLOCKPH${codeBlocks.length - 1}}}</pre>\\n`;\n    },\n  );\n};\n\n// Function to extract and store inline code\nconst extractInlineCode = (markdown: string): string => {\n  return markdown.replace(/`([^`]+)`/g, (_match, code) => {\n    inlineCode.push(code);\n    return `{{INLINECODEPH${inlineCode.length - 1}}}`;\n  });\n};\n\n// Function to restore code blocks with proper HTML escaping\nconst restoreCodeBlocks = (markdown: string): string => {\n  return markdown.replace(\n    /<pre>{{CODEBLOCKPH(\\d+)}}<\\/pre>/g,\n    (_match, index) => {\n      const code = codeBlocks[parseInt(index)];\n      return `<pre>${esc(code)}</pre>`;\n    },\n  );\n};\n\n// Function to restore inline code with proper HTML escaping\nconst restoreInlineCode = (markdown: string): string => {\n  return markdown.replace(/{{INLINECODEPH(\\d+)}}/g, (_match, index) => {\n    const code = inlineCode[parseInt(index)];\n    return `<code>${esc(code)}</code>`;\n  });\n};\n\n// Function to extract and store math blocks\nconst extractMathBlocks = (markdown: string): string => {\n  return markdown.replace(/\\n\\s*\\$\\$([^]*?)\\$\\$\\s*\\n/g, (_match, math) => {\n    mathBlocks.push(math.trim());\n    return `\\n{{MATHBLOCKPH${mathBlocks.length - 1}}}\\n`;\n  });\n};\n\n// Function to extract and store inline math\nconst extractInlineMath = (markdown: string): string => {\n  return markdown.replace(/\\$([^$\\n]+)\\$/g, (_match, math) => {\n    inlineMath.push(math);\n    return `{{INLINEMATHPH${inlineMath.length - 1}}}`;\n  });\n};\n\n// Function to restore math blocks\nconst restoreMathBlocks = (markdown: string): string => {\n  return markdown.replace(/{{MATHBLOCKPH(\\d+)}}/g, (_match, index) => {\n    const math = mathBlocks[parseInt(index)];\n    return `<div class=\"math-block\">${esc(math)}</div>`;\n  });\n};\n\n// Function to restore inline math\nconst restoreInlineMath = (markdown: string): string => {\n  return markdown.replace(/{{INLINEMATHPH(\\d+)}}/g, (_match, index) => {\n    const math = inlineMath[parseInt(index)];\n    return `<span class=\"math-inline\">${esc(math)}</span>`;\n  });\n};\n\n/** Pre-paragraph rules (everything except paragraph processing) */\nconst preParaRules = [\n  [/\\r\\n/g, '\\n'], // Remove \\r\n  [/\\n(#+)(.*)/g, header], // headers\n  [/!\\[([^\\[]+)\\]\\((?:javascript:)?([^\\)]+)\\)/g, '<img src=\"$2\" alt=\"$1\">'], // images, invoked before links\n  [/\\[([^\\[]+)\\]\\((?:javascript:)?([^\\)]+)\\)/g, '<a href=\"$2\">$1</a>'], // links\n  [/([^\\\\])(\\*\\*|__)(.*?(_|\\*)?)\\2/g, '$1<strong>$3</strong>'], // bold\n  [/([^\\\\])(\\*|_)(.*?)\\2/g, '$1<em>$3</em>'], // emphasis\n  [/\\\\_/g, '&#95;'], // underscores part 1\n  [/\\~\\~(.*?)\\~\\~/g, '<del>$1</del>'], // del\n  [/\\:\\\"(.*?)\\\"\\:/g, '<q>$1</q>'], // quote\n  [/\\n-{3,}/g, '\\n<hr />'], // horizontal rule (must come before ul lists)\n  [/\\n( *)[-*+] \\[([xX ])\\](.*)/g, taskList], // task lists with checkboxes (must come before regular ul lists)\n  [/\\n( *)(\\*|-|\\+)(.*)/g, ulList], // ul lists using +, - or * to denote an entry\n  [/\\n( *)([0-9]+\\.) (.*)/g, olList], // ol lists\n  [/\\n(&gt;|\\>)(.*)/g, blockquote], // blockquotes\n  [/(\\^)(.*?)\\1/g, '<sup>$2</sup>'], // superscript\n  [/(\\~)(.*?)\\1/g, '<sub>$2</sub>'], // subscript\n  [\n    /\\n\\[(.+?)\\]\\n( *\\|[^\\n]+\\|\\r?\\n)((?: *\\|:?[ -]+:?)+ *\\|)(\\n(?: *\\|[^\\n]+\\|\\r?\\n?)*)?/g,\n    tableWithCaption,\n  ], // tables with captions\n  [\n    /( *\\|[^\\n]+\\|\\r?\\n)((?: *\\|:?[ -]+:?)+ *\\|)(\\n(?: *\\|[^\\n]+\\|\\r?\\n?)*)?/g,\n    table,\n  ], // regular tables\n  [/\\[\\^([^\\]]+)\\](?!:)/g, footnoteReferenceReplacer], // footnote references\n  [/\\[\\^([^\\]]+)\\]:\\s*((?:[^\\n]*\\n?)*)/g, footnoteDefinitionReplacer], // footnote definitions\n  [/\\n([A-Z][A-Za-z\\s]*?)\\s:\\s*([A-Z][^\\n]*)/g, definitionList], // definition lists (Capitalized Term : Capitalized Definition)\n] as Array<[RegExp, RegexReplacer | string]>;\n\n/** Post-paragraph rules (cleanup rules that run after paragraph processing) */\nconst postParaRules = [\n  [/\\s?<\\/[ou]l>\\s?<[ou]l>/g, '', 3], // fix extra ol and ul\n  [/<\\/blockquote>\\n<blockquote>/g, '<br>\\n'], // fix extra blockquote\n  [/https?:\\/\\/[^\"']*/g, cleanUpUrl], // fix em in links\n  [/&#95;/g, '_'], // underscores part 2\n] as Array<[RegExp, RegexReplacer | string]>;\n\n/**\n * Render Markdown text into HTML.\n *\n * @param markdown Markdown text\n * @param removeParagraphs If true (default false), remove the \\<p\\>...\\</p\\> around paragraphs\n * @param externalLinks If true (default false), replace \\<a href...\\> with \\<a taget=\"_blank\" href...\\>\n * to open them in a new page\n * @returns\n */\nexport const render = (\n  markdown: string,\n  removeParagraphs = false,\n  externalLinks = false,\n) => {\n  // Reset the storage arrays\n  codeBlocks.length = 0;\n  inlineCode.length = 0;\n  mathBlocks.length = 0;\n  inlineMath.length = 0;\n  footnotes.length = 0;\n\n  // Extract code blocks, math, and inline code before processing\n  markdown = extractCodeBlocks(`\\n${markdown}\\n`);\n  markdown = extractMathBlocks(markdown);\n  markdown = extractInlineCode(markdown);\n  markdown = extractInlineMath(markdown);\n\n  // Apply pre-paragraph rules\n  preParaRules.forEach(([regex, subst, repeat = 1]) => {\n    for (let i = 0; i < repeat; i++) {\n      markdown = markdown.replace(regex, subst as any);\n    }\n  });\n\n  // Process collected list items into proper nested structure\n  markdown = processListItems(markdown);\n\n  // Apply paragraph processing\n  markdown = markdown.replace(/\\n([^\\n]+)\\n/g, para);\n\n  // Apply post-paragraph cleanup rules\n  postParaRules.forEach(([regex, subst, repeat = 1]) => {\n    for (let i = 0; i < repeat; i++) {\n      markdown = markdown.replace(regex, subst as any);\n    }\n  });\n\n  // Restore code blocks, math, and inline code with proper escaping\n  markdown = restoreCodeBlocks(markdown);\n  markdown = restoreMathBlocks(markdown);\n  markdown = restoreInlineCode(markdown);\n  markdown = restoreInlineMath(markdown);\n\n  // Add footnotes section if there are any footnotes\n  markdown = markdown.trim() + generateFootnotesSection();\n\n  if (removeParagraphs) {\n    markdown = markdown.replace(/^<p>(.*)<\\/p>$/s, '$1');\n  }\n  if (externalLinks) {\n    markdown = markdown.replace(/<a href=\"/g, '<a target=\"_blank\" href=\"');\n  }\n  return markdown;\n};\n\n/**\n * Add a new rule: The regex should be global and not use multiline mode.\n */\nexport const addRule = (regex: RegExp, replacement: RegexReplacer | string) => {\n  preParaRules.push([regex, replacement]);\n};\n"],"names":["codeBlocks","inlineCode","mathBlocks","inlineMath","footnotes","escapeMap","escRegex","RegExp","Object","keys","join","esc","s","replace","match","para","_","line","trimmed","trim","test","buildNestedList","listItems","length","html","stack","i","item","nextItem","level","last","pop","hasOpenLi","type","push","content","table","headers","format","align","split","filter","__","arr","map","col","td","a","rawHeaderCells","slice","headerCells","hd","headerResults","skipNext","spanCount","hasTrulyEmptyCell","j","row","rawCells","cells","cell","cellResults","preParaRules","h","_text","indent","checkboxState","Math","floor","toLowerCase","_bullet","caption","_match","id","text","term","definition","postParaRules","link","render","markdown","removeParagraphs","externalLinks","math","extractInlineMath","code","extractInlineCode","extractMathBlocks","extractCodeBlocks","forEach","regex","subst","repeat","includes","lines","groups","currentGroup","hasEmptyLineSinceLastItem","listMatch","itemType","itemLevel","parseInt","lastItem","originalLine","group","processListItems","index","restoreInlineMath","restoreInlineCode","restoreMathBlocks","restoreCodeBlocks","addRule","replacement"],"mappings":"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"}
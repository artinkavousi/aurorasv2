{"version":3,"file":"slimdown.umd.js","sources":["../src/index.ts"],"sourcesContent":["export type RegexReplacer = (substring: string, ...args: any[]) => string;\n\n/**\n * Slimdown - A very basic regex-based Markdown parser. Supports the\n * following elements (and can be extended via Slimdown::add_rule()):\n *\n * - Headers\n * - Images\n * - Links\n * - Bold\n * - Emphasis\n * - Deletions\n * - Quotes\n * - Inline code\n * - Code blocks\n * - Blockquotes\n * - Ordered/unordered lists (one level only)\n * - Horizontal rules\n * - Superscript and subscript (`z_1_` or `a^2^`)\n *\n * Original author: Johnny Broadway <johnny@johnnybroadway.com>\n * Website: https://gist.github.com/jbroadway/2836900\n * Inspiration:\n * - https://gist.github.com/plugnburn/f0d12e38b6416a77c098\n * - https://github.com/Chalarangelo/parse-md-js/blob/master/parsemd.js\n * - https://gist.github.com/plugnburn/f0d12e38b6416a77c098\n *\n * Author: Erik Vullings <erik.vullings@gmail.com>\n * Conversion from PHP to TypeScript, applying fixes and tests, adding more elements, and publishing to npm:\n * Website: https://github.com/erikvullings/slimdown-js\n * License: MIT\n */\n\n// Store code blocks temporarily to prevent markdown processing within them\nconst codeBlocks: string[] = [];\nconst inlineCode: string[] = [];\n// Store math expressions to prevent markdown processing within them\nconst mathBlocks: string[] = [];\nconst inlineMath: string[] = [];\n// Store footnotes\nconst footnotes: Array<[id: string, text: string]> = [];\n\nconst escapeMap: Record<string, string> = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\n\nconst escRegex = new RegExp(`[${Object.keys(escapeMap).join('')}]`, 'g');\n\nconst esc = (s: string): string =>\n  s.replace(escRegex, (match) => escapeMap[match]);\n\nconst para = (_: string, line: string) => {\n  const trimmed = line.trim();\n  return /^<\\/?(ul|ol|li|h|p|bl|table|tbody|tr|td|th|caption)/i.test(trimmed) || trimmed === ''\n    ? `\\n${line}\\n`\n    : `\\n<p>\\n${trimmed}\\n</p>\\n`;\n};\n\nconst ulList = (\n  _text: string,\n  indent: string,\n  _bullet: string,\n  item: string,\n) => {\n  const level = Math.floor(indent.length / 2);\n  return `\\n{{LISTITEM:ul:${level}:${item.trim()}}}\\n`;\n};\n\nconst olList = (\n  _text: string,\n  indent: string,\n  _bullet: string,\n  item: string,\n) => {\n  const level = Math.floor(indent.length / 2);\n  return `\\n{{LISTITEM:ol:${level}:${item.trim()}}}\\n`;\n};\n\nconst blockquote = (_: string, __: string, item = '') =>\n  `\\n<blockquote>${item.trim()}</blockquote>`;\n\nconst taskList = (\n  _text: string,\n  indent: string,\n  checkboxState: string,\n  item: string,\n) => {\n  const level = Math.floor(indent.length / 2);\n  const checked = checkboxState.toLowerCase() === 'x';\n  const checkboxHtml = `<input type=\"checkbox\"${\n    checked ? ' checked' : ''\n  } disabled>`;\n  return `\\n{{LISTITEM:ul:${level}:${checkboxHtml} ${item.trim()}}}\\n`;\n};\n\nconst definitionList = (_: string, term: string, definition: string) => {\n  return `\\n<dl><dt>${term.trim()}</dt><dd>${definition.trim()}</dd></dl>\\n`;\n};\n\n// Function to process list items into proper nested HTML\nconst processListItems = (markdown: string): string => {\n  if (!markdown.includes('{{LISTITEM:')) return markdown;\n\n  // Find groups of consecutive list items separated by non-list content\n  const lines = markdown.split('\\n');\n  const groups: Array<\n    Array<{\n      type: 'ul' | 'ol';\n      level: number;\n      content: string;\n      originalLine: string;\n    }>\n  > = [];\n  let currentGroup: Array<{\n    type: 'ul' | 'ol';\n    level: number;\n    content: string;\n    originalLine: string;\n  }> = [];\n\n  let hasEmptyLineSinceLastItem = false;\n\n  for (const line of lines) {\n    const listMatch = line.match(/\\{\\{LISTITEM:([^:]+):([^:]+):(.+)\\}\\}/);\n    if (listMatch) {\n      const itemType = listMatch[1] as 'ul' | 'ol';\n      const itemLevel = parseInt(listMatch[2]);\n\n      // Check if we should break the group due to type change after empty line\n      if (hasEmptyLineSinceLastItem && currentGroup.length > 0) {\n        const lastItem = currentGroup[currentGroup.length - 1];\n        // Break group if type changes at the same level after empty line\n        if (lastItem.type !== itemType && lastItem.level === itemLevel) {\n          groups.push([...currentGroup]);\n          currentGroup = [];\n        }\n      }\n\n      currentGroup.push({\n        type: itemType,\n        level: itemLevel,\n        content: listMatch[3],\n        originalLine: line,\n      });\n      hasEmptyLineSinceLastItem = false;\n    } else if (line.trim() !== '') {\n      // Non-empty, non-list line - end current group\n      if (currentGroup.length > 0) {\n        groups.push([...currentGroup]);\n        currentGroup = [];\n      }\n      hasEmptyLineSinceLastItem = false;\n    } else if (line.trim() === '') {\n      // Empty line\n      hasEmptyLineSinceLastItem = true;\n    }\n  }\n\n  // Add final group if any\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  }\n\n  if (groups.length === 0) return markdown;\n\n  // Process each group separately\n  for (const group of groups) {\n    const html = buildNestedList(group);\n\n    // Replace first item in group with the complete HTML\n    const firstItem = group[0];\n    markdown = markdown.replace(firstItem.originalLine, html);\n\n    // Remove remaining items in group\n    for (let i = 1; i < group.length; i++) {\n      markdown = markdown.replace(group[i].originalLine, '');\n    }\n  }\n\n  return markdown;\n};\n\n// Build nested HTML from a group of list items\nconst buildNestedList = (\n  listItems: Array<{\n    type: 'ul' | 'ol';\n    level: number;\n    content: string;\n    originalLine: string;\n  }>,\n): string => {\n  if (listItems.length === 0) return '';\n\n  let html = '';\n  const stack: Array<{ type: 'ul' | 'ol'; level: number; hasOpenLi: boolean }> =\n    [];\n\n  for (let i = 0; i < listItems.length; i++) {\n    const item = listItems[i];\n    const nextItem = i < listItems.length - 1 ? listItems[i + 1] : null;\n\n    // Close lists that are deeper than current level\n    while (stack.length > 0 && stack[stack.length - 1].level > item.level) {\n      const last = stack.pop()!;\n      if (last.hasOpenLi) {\n        html += '</li>';\n      }\n      html += `</${last.type}>`;\n    }\n\n    // Close current list if switching types at same level\n    if (\n      stack.length > 0 &&\n      stack[stack.length - 1].level === item.level &&\n      stack[stack.length - 1].type !== item.type\n    ) {\n      const last = stack.pop()!;\n      if (last.hasOpenLi) {\n        html += '</li>';\n      }\n      html += `</${last.type}>`;\n    }\n\n    // Open new list if needed\n    if (stack.length === 0 || stack[stack.length - 1].level < item.level) {\n      html += `<${item.type}>`;\n      stack.push({ type: item.type, level: item.level, hasOpenLi: false });\n    }\n\n    // Close previous li at same level if needed\n    if (\n      stack.length > 0 &&\n      stack[stack.length - 1].hasOpenLi &&\n      stack[stack.length - 1].level === item.level\n    ) {\n      html += '</li>';\n      stack[stack.length - 1].hasOpenLi = false;\n    }\n\n    // Add list item\n    html += `<li>${item.content}`;\n    stack[stack.length - 1].hasOpenLi = true;\n\n    // Close li if next item is not deeper\n    if (!nextItem || nextItem.level <= item.level) {\n      html += '</li>';\n      stack[stack.length - 1].hasOpenLi = false;\n    }\n  }\n\n  // Close remaining lists\n  while (stack.length > 0) {\n    const last = stack.pop()!;\n    if (last.hasOpenLi) {\n      html += '</li>';\n    }\n    html += `</${last.type}>`;\n  }\n\n  return html;\n};\n\n// Process footnote references in the text [^1]\nconst footnoteReferenceReplacer = (_match: string, id: string) => {\n  // Create a link inside a superscript tag with proper references\n  return `<sup id=\"fnref:${id}\"><a href=\"#fn:${id}\">[${id}]</a></sup>`;\n};\n\n// Process footnote definitions [^1]: Footnote text\nconst footnoteDefinitionReplacer = (\n  _match: string,\n  id: string,\n  text: string,\n) => {\n  footnotes.push([id, text.trim()]);\n  return ''; // Remove the definition from the main text\n};\n\n// Generate the footnotes section\nconst generateFootnotesSection = () => {\n  if (footnotes.length === 0) return '';\n\n  const footnotesHtml = footnotes\n    .map(\n      ([id, text]) => `\n    <li id=\"fn:${id}\">\n      ${text}\n      <sup><a href=\"#fnref:${id}\">â†©</a></sup>\n    </li>`,\n    )\n    .join('\\n');\n\n  return `\n<div class=\"footnotes\">\n  <hr>\n  <ol>\n    ${footnotesHtml}\n  </ol>\n</div>`;\n};\n\nconst table = (\n  _: string,\n  headers: string,\n  format: string,\n  content: string = '',\n) => {\n  const align = format\n    .split('|')\n    .filter((__, i, arr) => i > 0 && i < arr.length - 1)\n    .map((col) =>\n      /:-+:/g.test(col)\n        ? 'center'\n        : /-+:/g.test(col)\n        ? 'right'\n        : /:-+/.test(col)\n        ? 'left'\n        : '',\n    );\n\n  // Return attribute string (keeps compatibility with original code's template)\n  const td = (col: number) => {\n    const a = align[col];\n    return a ? ` align=\"${a}\"` : '';\n  };\n\n  // Parse header cells (keep both raw and trimmed for emptiness checks)\n  const rawHeaderCells = headers.split('|').slice(1, -1); // remove first and last empty elements\n  const headerCells = rawHeaderCells.map((hd) => hd.trim());\n\n  const headerResults: string[] = [];\n  let skipNext = 0;\n\n  for (let i = 0; i < headerCells.length; i++) {\n    if (skipNext > 0) {\n      skipNext--;\n      continue;\n    }\n\n    const hd = headerCells[i];\n    const rawHd = rawHeaderCells[i];\n    \n    if (hd && hd.length) {\n      // count how many consecutive empty header cells follow -> colspan\n      // Only do colspan if there's at least one truly empty cell (from ||) in the sequence\n      let spanCount = 1;\n      let hasTrulyEmptyCell = false;\n      \n      // Check if there are any truly empty cells following this cell\n      for (let j = i + 1; j < headerCells.length && headerCells[j].length === 0; j++) {\n        if (rawHeaderCells[j] === '') {\n          hasTrulyEmptyCell = true;\n          break;\n        }\n      }\n      \n      // Only count consecutive empty cells for colspan if we found truly empty cells\n      if (hasTrulyEmptyCell) {\n        for (\n          let j = i + 1;\n          j < headerCells.length && headerCells[j].length === 0;\n          j++\n        ) {\n          spanCount++;\n        }\n      }\n\n      if (spanCount > 1) {\n        skipNext = spanCount - 1;\n        headerResults.push(`<th${td(i)} colspan=\"${spanCount}\">${hd}</th>`);\n      } else {\n        headerResults.push(`<th${td(i)}>${hd}</th>`);\n      }\n    } else {\n      // Check if this is a truly empty cell (from ||) or just whitespace\n      if (rawHd === '') {\n        // This is a truly empty cell that should be skipped for colspan\n        // But if we reach here, it means it wasn't part of a colspan, so render empty th\n        headerResults.push(`<th${td(i)}></th>`);\n      } else {\n        // This is a whitespace-only cell that should remain as individual cell\n        headerResults.push(`<th${td(i)}></th>`);\n      }\n    }\n  }\n\n  const h = `<tr>\\n  ${headerResults.join('\\n  ')}\\n</tr>\\n`;\n\n  // body rows\n  const rows = content\n    .split('\\n')\n    .map((row) => row.trim())\n    .filter((row) => row && row.length);\n\n  const c = rows\n    .map((row) => {\n      // Split by | but keep track of truly empty cells (from ||)\n      const rawCells = row.split('|').slice(1, -1); // remove first and last empty elements\n      const cells = rawCells.map((cell) => cell.trim());\n\n      const cellResults: string[] = [];\n      let skipNext = 0;\n\n      for (let i = 0; i < cells.length; i++) {\n        if (skipNext > 0) {\n          skipNext--;\n          continue;\n        }\n\n        const cell = cells[i];\n        const rawCell = rawCells[i];\n        \n        if (cell && cell.length) {\n          // Count consecutive empty cells after this one -> colspan\n          // Only do colspan if there's at least one truly empty cell (from ||) in the sequence\n          let spanCount = 1;\n          let hasTrulyEmptyCell = false;\n          \n          // Check if there are any truly empty cells following this cell\n          for (let j = i + 1; j < cells.length && cells[j].length === 0; j++) {\n            if (rawCells[j] === '') {\n              hasTrulyEmptyCell = true;\n              break;\n            }\n          }\n          \n          // Only count consecutive empty cells for colspan if we found truly empty cells\n          if (hasTrulyEmptyCell) {\n            for (\n              let j = i + 1;\n              j < cells.length && cells[j].length === 0;\n              j++\n            ) {\n              spanCount++;\n            }\n          }\n          if (spanCount > 1) {\n            skipNext = spanCount - 1;\n            cellResults.push(`<td${td(i)} colspan=\"${spanCount}\">${cell}</td>`);\n          } else {\n            cellResults.push(`<td${td(i)}>${cell}</td>`);\n          }\n        } else {\n          // Check if this is a truly empty cell (from ||) or just whitespace\n          if (rawCell === '') {\n            // This is a truly empty cell that should be skipped for colspan\n            // But if we reach here, it means it wasn't part of a colspan, so render empty td\n            cellResults.push(`<td${td(i)}></td>`);\n          } else {\n            // This is a whitespace-only cell that should remain as individual cell\n            cellResults.push(`<td${td(i)}></td>`);\n          }\n        }\n      }\n\n      return `<tr>\\n  ${cellResults.join('\\n  ')}\\n</tr>\\n`;\n    })\n    .join('');\n\n  // keep the original surrounding newlines/structure to stay compatible\n  return `\\n<table><tbody>${h}${c}</tbody></table>\\n`;\n};\n\n// Enhanced table with caption support\nconst tableWithCaption = (\n  _: string,\n  caption: string,\n  headers: string,\n  format: string,\n  content: string = '',\n) => {\n  const tableHtml = table(_, headers, format, content);\n  // Insert caption after <table> tag\n  return tableHtml.replace(\n    '<table>',\n    `<table><caption>${caption.trim()}</caption>`,\n  );\n};\n\nconst cleanUpUrl = (link: string) => link.replace(/<\\/?em>/g, '_');\n\nconst header = (_: string, match: string, h = '') => {\n  const level = match.length;\n  return `<h${level}>${h.trim()}</h${level}>`;\n};\n\n// Function to extract and store code blocks\nconst extractCodeBlocks = (markdown: string): string => {\n  return markdown.replace(\n    /\\n\\s*```\\w*\\n([^]*?)\\n\\s*```\\s*\\n/g,\n    (_match, code) => {\n      codeBlocks.push(code);\n      return `\\n<pre>{{CODEBLOCKPH${codeBlocks.length - 1}}}</pre>\\n`;\n    },\n  );\n};\n\n// Function to extract and store inline code\nconst extractInlineCode = (markdown: string): string => {\n  return markdown.replace(/`([^`]+)`/g, (_match, code) => {\n    inlineCode.push(code);\n    return `{{INLINECODEPH${inlineCode.length - 1}}}`;\n  });\n};\n\n// Function to restore code blocks with proper HTML escaping\nconst restoreCodeBlocks = (markdown: string): string => {\n  return markdown.replace(\n    /<pre>{{CODEBLOCKPH(\\d+)}}<\\/pre>/g,\n    (_match, index) => {\n      const code = codeBlocks[parseInt(index)];\n      return `<pre>${esc(code)}</pre>`;\n    },\n  );\n};\n\n// Function to restore inline code with proper HTML escaping\nconst restoreInlineCode = (markdown: string): string => {\n  return markdown.replace(/{{INLINECODEPH(\\d+)}}/g, (_match, index) => {\n    const code = inlineCode[parseInt(index)];\n    return `<code>${esc(code)}</code>`;\n  });\n};\n\n// Function to extract and store math blocks\nconst extractMathBlocks = (markdown: string): string => {\n  return markdown.replace(/\\n\\s*\\$\\$([^]*?)\\$\\$\\s*\\n/g, (_match, math) => {\n    mathBlocks.push(math.trim());\n    return `\\n{{MATHBLOCKPH${mathBlocks.length - 1}}}\\n`;\n  });\n};\n\n// Function to extract and store inline math\nconst extractInlineMath = (markdown: string): string => {\n  return markdown.replace(/\\$([^$\\n]+)\\$/g, (_match, math) => {\n    inlineMath.push(math);\n    return `{{INLINEMATHPH${inlineMath.length - 1}}}`;\n  });\n};\n\n// Function to restore math blocks\nconst restoreMathBlocks = (markdown: string): string => {\n  return markdown.replace(/{{MATHBLOCKPH(\\d+)}}/g, (_match, index) => {\n    const math = mathBlocks[parseInt(index)];\n    return `<div class=\"math-block\">${esc(math)}</div>`;\n  });\n};\n\n// Function to restore inline math\nconst restoreInlineMath = (markdown: string): string => {\n  return markdown.replace(/{{INLINEMATHPH(\\d+)}}/g, (_match, index) => {\n    const math = inlineMath[parseInt(index)];\n    return `<span class=\"math-inline\">${esc(math)}</span>`;\n  });\n};\n\n/** Pre-paragraph rules (everything except paragraph processing) */\nconst preParaRules = [\n  [/\\r\\n/g, '\\n'], // Remove \\r\n  [/\\n(#+)(.*)/g, header], // headers\n  [/!\\[([^\\[]+)\\]\\((?:javascript:)?([^\\)]+)\\)/g, '<img src=\"$2\" alt=\"$1\">'], // images, invoked before links\n  [/\\[([^\\[]+)\\]\\((?:javascript:)?([^\\)]+)\\)/g, '<a href=\"$2\">$1</a>'], // links\n  [/([^\\\\])(\\*\\*|__)(.*?(_|\\*)?)\\2/g, '$1<strong>$3</strong>'], // bold\n  [/([^\\\\])(\\*|_)(.*?)\\2/g, '$1<em>$3</em>'], // emphasis\n  [/\\\\_/g, '&#95;'], // underscores part 1\n  [/\\~\\~(.*?)\\~\\~/g, '<del>$1</del>'], // del\n  [/\\:\\\"(.*?)\\\"\\:/g, '<q>$1</q>'], // quote\n  [/\\n-{3,}/g, '\\n<hr />'], // horizontal rule (must come before ul lists)\n  [/\\n( *)[-*+] \\[([xX ])\\](.*)/g, taskList], // task lists with checkboxes (must come before regular ul lists)\n  [/\\n( *)(\\*|-|\\+)(.*)/g, ulList], // ul lists using +, - or * to denote an entry\n  [/\\n( *)([0-9]+\\.) (.*)/g, olList], // ol lists\n  [/\\n(&gt;|\\>)(.*)/g, blockquote], // blockquotes\n  [/(\\^)(.*?)\\1/g, '<sup>$2</sup>'], // superscript\n  [/(\\~)(.*?)\\1/g, '<sub>$2</sub>'], // subscript\n  [\n    /\\n\\[(.+?)\\]\\n( *\\|[^\\n]+\\|\\r?\\n)((?: *\\|:?[ -]+:?)+ *\\|)(\\n(?: *\\|[^\\n]+\\|\\r?\\n?)*)?/g,\n    tableWithCaption,\n  ], // tables with captions\n  [\n    /( *\\|[^\\n]+\\|\\r?\\n)((?: *\\|:?[ -]+:?)+ *\\|)(\\n(?: *\\|[^\\n]+\\|\\r?\\n?)*)?/g,\n    table,\n  ], // regular tables\n  [/\\[\\^([^\\]]+)\\](?!:)/g, footnoteReferenceReplacer], // footnote references\n  [/\\[\\^([^\\]]+)\\]:\\s*((?:[^\\n]*\\n?)*)/g, footnoteDefinitionReplacer], // footnote definitions\n  [/\\n([A-Z][A-Za-z\\s]*?)\\s:\\s*([A-Z][^\\n]*)/g, definitionList], // definition lists (Capitalized Term : Capitalized Definition)\n] as Array<[RegExp, RegexReplacer | string]>;\n\n/** Post-paragraph rules (cleanup rules that run after paragraph processing) */\nconst postParaRules = [\n  [/\\s?<\\/[ou]l>\\s?<[ou]l>/g, '', 3], // fix extra ol and ul\n  [/<\\/blockquote>\\n<blockquote>/g, '<br>\\n'], // fix extra blockquote\n  [/https?:\\/\\/[^\"']*/g, cleanUpUrl], // fix em in links\n  [/&#95;/g, '_'], // underscores part 2\n] as Array<[RegExp, RegexReplacer | string]>;\n\n/**\n * Render Markdown text into HTML.\n *\n * @param markdown Markdown text\n * @param removeParagraphs If true (default false), remove the \\<p\\>...\\</p\\> around paragraphs\n * @param externalLinks If true (default false), replace \\<a href...\\> with \\<a taget=\"_blank\" href...\\>\n * to open them in a new page\n * @returns\n */\nexport const render = (\n  markdown: string,\n  removeParagraphs = false,\n  externalLinks = false,\n) => {\n  // Reset the storage arrays\n  codeBlocks.length = 0;\n  inlineCode.length = 0;\n  mathBlocks.length = 0;\n  inlineMath.length = 0;\n  footnotes.length = 0;\n\n  // Extract code blocks, math, and inline code before processing\n  markdown = extractCodeBlocks(`\\n${markdown}\\n`);\n  markdown = extractMathBlocks(markdown);\n  markdown = extractInlineCode(markdown);\n  markdown = extractInlineMath(markdown);\n\n  // Apply pre-paragraph rules\n  preParaRules.forEach(([regex, subst, repeat = 1]) => {\n    for (let i = 0; i < repeat; i++) {\n      markdown = markdown.replace(regex, subst as any);\n    }\n  });\n\n  // Process collected list items into proper nested structure\n  markdown = processListItems(markdown);\n\n  // Apply paragraph processing\n  markdown = markdown.replace(/\\n([^\\n]+)\\n/g, para);\n\n  // Apply post-paragraph cleanup rules\n  postParaRules.forEach(([regex, subst, repeat = 1]) => {\n    for (let i = 0; i < repeat; i++) {\n      markdown = markdown.replace(regex, subst as any);\n    }\n  });\n\n  // Restore code blocks, math, and inline code with proper escaping\n  markdown = restoreCodeBlocks(markdown);\n  markdown = restoreMathBlocks(markdown);\n  markdown = restoreInlineCode(markdown);\n  markdown = restoreInlineMath(markdown);\n\n  // Add footnotes section if there are any footnotes\n  markdown = markdown.trim() + generateFootnotesSection();\n\n  if (removeParagraphs) {\n    markdown = markdown.replace(/^<p>(.*)<\\/p>$/s, '$1');\n  }\n  if (externalLinks) {\n    markdown = markdown.replace(/<a href=\"/g, '<a target=\"_blank\" href=\"');\n  }\n  return markdown;\n};\n\n/**\n * Add a new rule: The regex should be global and not use multiline mode.\n */\nexport const addRule = (regex: RegExp, replacement: RegexReplacer | string) => {\n  preParaRules.push([regex, replacement]);\n};\n"],"names":["codeBlocks","inlineCode","mathBlocks","inlineMath","footnotes","escapeMap","escRegex","RegExp","Object","keys","join","esc","s","replace","match","para","_","line","trimmed","trim","test","buildNestedList","listItems","length","html","stack","i","item","nextItem","level","last","pop","hasOpenLi","type","push","content","table","headers","format","align","split","filter","__","arr","map","col","td","a","rawHeaderCells","slice","headerCells","hd","headerResults","skipNext","spanCount","hasTrulyEmptyCell","j","row","rawCells","cells","cell","cellResults","preParaRules","h","_text","indent","checkboxState","Math","floor","toLowerCase","_bullet","caption","_match","id","text","term","definition","postParaRules","link","regex","replacement","markdown","removeParagraphs","externalLinks","math","extractInlineMath","code","extractInlineCode","extractMathBlocks","extractCodeBlocks","forEach","subst","repeat","includes","groups","currentGroup","hasEmptyLineSinceLastItem","listMatch","itemType","itemLevel","parseInt","lastItem","originalLine","group","processListItems","index","restoreInlineMath","restoreInlineCode","restoreMathBlocks","restoreCodeBlocks"],"mappings":"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"}